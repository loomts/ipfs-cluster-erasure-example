package utils

// copy from https://github.com/ipfs-cluster/ipfs-cluster/test/sharding.go

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/cheggaaa/pb"
	files "github.com/ipfs/boxo/files"
	"github.com/ipfs/boxo/path"
	"github.com/ipfs/go-cid"
	logging "github.com/ipfs/go-log/v2"
	ipfshttp "github.com/ipfs/kubo/client/rpc"
	"github.com/multiformats/go-multiaddr"
)

var log = logging.Logger("cluster")

const (
	SourceDir   = "source"
	RetrieveDir = "retrieve"
	Tree        = "Tree"
	file        = "File"
)

func GetFileName(i int) string {
	return fmt.Sprintf("%s%d", file, i)
}

// Variables related to adding the testing directory generated by tests
var (
	ShardingDirRootCID = "QmQj41GPFvFsFRWKXzcjAwAoU3ykUj9wQAM6DQG9dgvhNc" // ~100.9MB
)

// fileHelper helps generating files and folders to test adding and
// sharding in IPFS Cluster
type fileHelper struct {
	randSrc *rand.Rand
}

type ECFile struct {
	Mfr *files.MultiFileReader
	io.Closer
	Name string
	Base string
	Size uint64
}

// NewFileHelper returns a new helper.
func NewFileHelper() *fileHelper {
	return &fileHelper{
		randSrc: rand.New(rand.NewSource(1)),
	}
}

// GetTreeMultiReader creates and returns a MultiFileReader for a testing
// directory tree. Files are pseudo-randomly generated and are always the same.
func (sth *fileHelper) GetTreeMultiReader() ECFile {
	sf := sth.GetTreeSerialFile()
	mapDir := files.NewMapDirectory(map[string]files.Node{
		Tree: sf,
	})
	sz, err := sf.Size()
	if err != nil {
		log.Error(err)
	}
	return ECFile{files.NewMultiFileReader(mapDir, true, false), sf, Tree, SourceDir, uint64(sz)}
}

// GetTreeSerialFile returns a files.Directory pointing to the testing
// directory tree (see GetTreeMultiReader).
func (sth *fileHelper) GetTreeSerialFile() files.Directory {
	st := sth.makeTree()
	sf, err := files.NewSerialFile(sth.path(Tree), false, st)

	if err != nil {
		log.Error(err)
	}
	return sf.(files.Directory)
}

// GetRandFileMultiReader creates and returns a MultiFileReader for
// a testing random file of the given size (in kbs). The random
// file is different every time.
func (sth *fileHelper) GetRandFileMultiReader() []ECFile {
	fs := make([]ECFile, 21)
	for i := 0; i <= 20; i++ {
		kbs := 1 << i
		slf, sf := sth.GetRandFileReader(kbs, GetFileName(i))
		fs[i] = ECFile{slf, sf, GetFileName(i), SourceDir, uint64(kbs * 1024)}
	}
	return fs
}

func (sth *fileHelper) Get1GBRandFileMultiReader() []ECFile {
	fs := make([]ECFile, 21)
	for i := 0; i <= 20; i++ {
		kbs := 1 << 20
		slf, sf := sth.GetRandFileReader(kbs, GetFileName(i))
		fs[i] = ECFile{slf, sf, GetFileName(i), SourceDir, uint64(kbs * 1024)}
	}
	return fs
}

func (sth *fileHelper) GetRandFilePath(kbs int, name string) {
	sth.makeRandFile(kbs, name)
}

// GetRandFileReader creates and returns a directory containing a testing
// random file of the given size (in kbs)
func (sth *fileHelper) GetRandFileReader(kbs int, name string) (*files.MultiFileReader, io.Closer) {
	st := sth.makeRandFile(kbs, name)
	sf, err := files.NewSerialFile(sth.path(name), false, st)
	if err != nil {
		log.Error(err)
	}
	mapDir := files.NewMapDirectory(
		map[string]files.Node{name: sf},
	)
	return files.NewMultiFileReader(mapDir, true, false), sf
}

// Clean deletes any folder and file generated by this helper.
func (sth *fileHelper) Clean() {
	err := os.RemoveAll(SourceDir)
	if err != nil {
		log.Error(err)
	}
	// err = os.RemoveAll(RetrieveDir)
	// if err != nil {
	// 	log.Error(err)
	// }
}

func folderExists(path string) bool {
	if st, err := os.Stat(path); os.IsNotExist(err) {
		return false
	} else if err != nil {
		log.Error(err)
	} else if !st.IsDir() {
		log.Errorf("%s is not a directory", path)
	}
	return true
}

func makeDir(path string) {
	if !folderExists(path) {
		err := os.MkdirAll(path, os.ModePerm)
		if err != nil {
			log.Error(err)
		}
	}
}

// see GetTreeMultiReader
func (sth *fileHelper) makeTestFolder() {
	makeDir(SourceDir)
}

// This produces this:
// - source
//   - testTree
//   - A
//   - alpha
//   - small_file_0 (< 5 kB)
//   - beta
//   - small_file_1 (< 5 kB)
//   - delta
//   - empty
//   - small_file_2 (< 5 kB)
//   - gamma
//   - small_file_3 (< 5 kB)
//   - B
//   - medium_file (~.3 MB)
//   - big_file (~3 MB)
//   - C
//   - bigbig_file (< 100 MB)
//
// The total size in ext4 is 105,799,680 byte = ~100.9MB
// Take special care when modifying this function.  File data depends on order
// and each file size.  If this changes then hashes above
// recording the ipfs import hash tree must be updated manually.
func (sth *fileHelper) makeTree() os.FileInfo {
	sth.makeTestFolder()
	basepath := sth.path(Tree)

	// do not re-create
	if folderExists(basepath) {
		st, _ := os.Stat(basepath)
		return st
	}

	p0 := Tree
	paths := [][]string{
		{p0, "A", "alpha"},
		{p0, "A", "beta"},
		{p0, "A", "delta", "empty"},
		{p0, "A", "gamma"},
		{p0, "B"},
		{p0, "C"},
	}
	for _, p := range paths {
		makeDir(sth.path(p...))
	}

	files := [][]string{
		{p0, "A", "alpha", "small_file_0"},
		{p0, "A", "beta", "small_file_1"},
		{p0, "A", "small_file_2"},
		{p0, "A", "gamma", "small_file_3"},
		{p0, "B", "medium_file"},
		{p0, "B", "big_file"},
		{p0, "C", "bigbig_file"},
	}

	fileSizes := []int{5, 5, 5, 5, 300, 3000, 100000}
	for i, fpath := range files {
		path := sth.path(fpath...)
		f, err := os.Create(path)
		if err != nil {
			log.Error(err)
		}
		sth.randFile(f, fileSizes[i])
		f.Sync()
		f.Close()
	}
	st, err := os.Stat(basepath)
	if err != nil {
		log.Error(err)
	}
	return st
}

func (sth *fileHelper) path(p ...string) string {
	paths := append([]string{SourceDir}, p...)
	return filepath.Join(paths...)
}

// Writes randomness to a writer up to the given size (in kBs)
func (sth *fileHelper) randFile(w io.Writer, kbs int) {
	sth.randSrc.Seed(rand.Int63())
	buf := make([]byte, 1024)
	for i := 0; i < kbs; i++ {
		sth.randSrc.Read(buf) // read 1 kb
		if _, err := w.Write(buf); err != nil {
			log.Error(err)
		}
	}
}

// this creates shardingTestFile in the testFolder. It recreates it every time.
func (sth *fileHelper) makeRandFile(kbs int, name string) os.FileInfo {
	sth.makeTestFolder()
	path := sth.path(name)
	f, err := os.Open(path)
	if err == nil {
		// file exist
		st, err := f.Stat()
		if err != nil {
			log.Error(err)
			return nil
		}
		return st
	}
	f, err = os.Create(path)
	if err != nil {
		log.Error(err)
	}
	defer f.Close()
	defer f.Sync()
	sth.randFile(f, kbs)
	st, err := f.Stat()
	if err != nil {
		log.Error(err)
	}
	return st
}

func Diff(path1, path2 string) error {
	cmd := exec.Command("diff", "-r", path1, path2)
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		if _, ok := err.(*exec.ExitError); ok {
			return fmt.Errorf("%s and %s verify failed, not same", path1, path2)
		}
		return fmt.Errorf("%s and %s verify failed, something error:%s", path1, path2, err)
	}
	return nil
}

func IPFSGet(ci cid.Cid) error {
	mr, err := multiaddr.NewMultiaddr("/ip4/127.0.0.1/tcp/5001")
	if err != nil {
		return err
	}
	ipfs, err := ipfshttp.NewApi(mr)
	if err != nil {
		return err
	}
	err = ipfs.Request("version").Exec(context.Background(), nil)
	if err != nil {
		return err
	}

	out, err := ipfs.Unixfs().Get(context.Background(), path.FromCid(ci))
	if err != nil {
		return err
	}
	err = WriteTo(out, "/home/loomt/gopath/src/ipfs-cluster-erasure-example/retrieve/"+ci.String(), false)
	if err != nil {
		return err
	}
	return nil
}

// WriteTo writes the given node to the local filesystem at fpath.
func WriteTo(nd files.Node, fpath string, progress bool) error {
	s, err := nd.Size()
	if err != nil {
		return err
	}

	var bar *pb.ProgressBar
	if progress {
		bar = pb.New64(s).Start()
	}

	return writeToRec(nd, fpath, bar)
}

func writeToRec(nd files.Node, fpath string, bar *pb.ProgressBar) error {
	switch nd := nd.(type) {
	case *files.Symlink:
		return os.Symlink(nd.Target, fpath)
	case files.File:
		f, err := os.Create(fpath)
		defer f.Close()
		if err != nil {
			return err
		}

		var r io.Reader = nd
		if bar != nil {
			r = bar.NewProxyReader(r)
		}
		_, err = io.Copy(f, r)
		if err != nil {
			return err
		}
		return nil
	case files.Directory:
		err := os.Mkdir(fpath, 0777)
		if err != nil {
			return err
		}

		entries := nd.Entries()
		for entries.Next() {
			child := filepath.Join(fpath, entries.Name())
			if err := writeToRec(entries.Node(), child, bar); err != nil {
				return err
			}
		}
		return entries.Err()
	default:
		return fmt.Errorf("file type %T at %q is not supported", nd, fpath)
	}
}
